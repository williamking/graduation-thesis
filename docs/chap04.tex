%% chapter 4 dataset, network structure, experiment and result
\chapter{填空评测算法的改进}
\label{cha:aglorithm_improvement}

上一章的结尾，指出了初期的程序填空评测算法的缺陷，在这一章，本文会详细
分析算法出现的问题以及解决方案，
然后阐述改进算法的过程，最后说明对于改进算法所做的系统
代码的实现修改工作。

\section{问题与改进算法}
\subsection{旧评测算法中的问题}
通过总结之前算法在 Matrix 考试系统的部署和实践，总结出以下两点问题：
\begin{enumerate}
  \item 动态测试评测的整体限制，必须所有填空通过语法编译，动态评测才能运行。
  \item 对于一些出题，测试的程序有时无法应对一些等效答案。
下面对这两点问题提出解决的改进方式。
\end{enumerate}

\subsection{评测算法改进方案}

上一节分析了旧程序填空评测算法的问题主要在于动态评测的整体性限制上，因此本文在独立
填空评测上做突破点，对题目中的每一个填空，都进行一次动态测试，
具体的算法设计如算法{algo:ibc}。

\subsubsection{动态测试的改进}

\begin{algorithm}[h]
\KwIn{第$n$个填空的答案$answer_n$}
\KwOut{该填空对应的评测代码$code_n$}
将挖空代码$blankcode$赋值：$code_n = blankcode$

\ForAll{挖空的代码$blankcode$中的填空位置} {
  \If{该空为第$n$个空} {
    填入学生答案$answer_n$
  } \Else {
    填入标准答案$standardanswer_n$
  }
}
\caption{改进后的动态评测代码生成算法}
\label{algo:ibc}
\end{algorithm}

该算法对程序填空题提交的每一个填空，都生成了对应的一个提交代码，
隔离了语法错误的答案对其它答案造成的影响，使得动态测试部分的评测
更为科学。

\subsubsection{静态分析的改进}

一般的等效答案在填入挖空程序中执行，都会得到相同的结果。然而在图\ref{fig:prob_desc}
描述的题目与其测试结果测试的意图有所差异，因此出现了等效答案却无法得分的情况。面对这种
情形，较科学的解决方法为提供多个等效答案进行静态分析，取最大相似度作为静态分析的评分依据，
从而增大静态分析的准确率。

\subsection{对算法改进所进行的工作}

\subsubsection{因多次程序评测造成的问题}
对算法进行改进后，原本评测一次的动态测试过程变成了多次代码评测，这对于
评测系统产生了一定的问题。一是评测系统原本的评测逻辑是一次提交对应一次代码
评测，与程序填空题一次提交对应多次代码评测不符。二是评测系统只能识别当前评
测的提交代码，无法将其与其它提交联系在一起，因此评测系统无法将几次评测得出
填空得分同时获取并相加得出最终得分。
由于评测系统的评测逻辑存在交互协作问题，暂时无法进行修改，
因此改进工作的重点是在不对评测系统进行修改的情况下，完成对改进算
法的适应性部署。

\subsubsection{服务端对算法改进所做的适应性修改}
评测算法改进后，服务端对前端的提交的动态测试部分的处理流程如伪代码\ref{alog:deal_sub}:
\begin{algorithm}[h]
\KwIn{学生提交的填空答案数组$answers$}
\KwOut{该学生提交记录在数据库中的$id$}
\ForAll{答案数组$answers$中的答案} {
  按照算法\ref{algo:ibc}的描述，生成对应的评测程序，发送到文件系统保存，并在数据库中生成提交记录。

  请求评测系统对该提交记录进行动态测试评测。
}
生成一个总提交记录，内容为之前每一个答案生成的提交记录的id。
\caption{服务端对学生提交答案的处理}
\label{algo:deal_sub}
\end{algorithm}

由于评测系统无法识别来自同一个程序填空题的多个填空对应的提交，因此无法计算动态测试总分。
因此计算总分的工作放在服务端进行，算法同伪代码\ref{algo:cal_grade}

\begin{algorithm}[h]
\KwIn{要查询程序填空题成绩的学生学号$id$}
\KwOut{该学生的动态测试得分$grade$}
根据学号$id$在数据库中查出学生最后一次的提交记录$finalsub$。

根据$finalsub$中记录的填空提交记录id从数据库中获取每个填空对应的提交记录，得到提交记录数组$submissions$。

动态测试得分$dgrade = 0$。

\ForAll{$submissions$中的每一个提交记录中的得分} {
  $grade = grade + dynamicgrade / 100 * $ 该填空分值
}
\caption{改进后服务端计算动态测试部分得分}
\label{algo:cal_grade}
\end{algorithm}

该逻辑修改解决了评测系统对程序填空评测的改进的不适应的问题，然而缺陷在
于需要经过服务端的二次查询和计算才能得出动态测试部分的评测得分，在统计多个
学生的考试成绩时会有较大的代价消耗。

\subsection{另一个问题}
虽然分次动态测试解决了动态测试的整体性问题，但是另一个问题在于
动态测试划分的粒度。比如某程序填空题，它的第一个填空答案为$int a = 5;$,
第二个填空答案为$cout << 2 * a$，并且之后的非填空程序部分都没有这两个变量的引用。
像这种情况，其实只要保证两个填空的变量都是a即能得分。

然而现有的动态测试并不能保证这种情况的正确评分。原因是动态测试是每次取学生提交的一个填空答案，
其他填空都填上标准答案，以上面为例，并不能保证学生填写的第一个填空和标准答案的第二个填空是同一个
变量，这样反而会导致学生的两个填空都无法正确得分，尽管学生的答案是正确的。

要克服这个问题，一种方案是对每种可能出现的情况都进行评测，问题就变为：将$n$个填空分成$m$组（$n <= m$）,
每组至少一个填空。计算出所有分组的可能情况，对于每种情况，都进行一次
同算法\ref{algo:ibc}的处理，只是答案的填空和替换是以组为单位的。计算出每一组的动态分析得分后，取
最高分为动态分析得分。

然而该方案的另一个缺点在于分组情况数过多，根据排列组合原理，对于$n$个填空的分组情况数是随着n的增多
呈爆炸式增长的，并且对于每种情况进行一次改进动态分析，就要执行分组数$m$次的测试代码。这对于评测
系统的压力是巨大的。并且对于一道程序填空题，实际上产生关联的答案组并不是很多，很多时候的分组其实
是没有任何意义的。

因此得出了让出题者设定关联填空答案的第二种方案，在出题时，由出题者根据题目答案自行进行分组设定，
动态分析时以出题者的分组进行评测。但是该方案增加了出题者的工作量，增大了出题难度，需要出题者仔细
进行思考，用户体验较差。由于时间以及成本原因，并未在后面的实验中采用该解决方案。

\section{本章总结}
本章阐述了对程序填空算法的改进，以及对应在服务端的适应性修改，最后对
改进后的算法进行了分析。下一章会对改进的算法与初期算法进行实验性对比分析。

\clearpage
